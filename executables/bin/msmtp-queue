#!/usr/bin/env bash
# msmtp queue management utility
#
# Provides commands to process, check status, and clear the
# msmtp email queue that is populated by msmtp-send.
set -euo pipefail

DATA_DIR="${XDG_DATA_HOME:-$HOME/.local/share}"
QUEUE_DIR="${DATA_DIR}/msmtp-queue"
LOG_FILE="${DATA_DIR}/msmtp-queue-processor.log"
MSMTP_PATH="$(command -v msmtp)"

main() {
  if [[ $# -eq 0 ]]; then
    print_usage
    exit 1
  fi

  local subcommand="$1"
  shift

  case "$subcommand" in
  process)
    process_queue "$@"
    ;;
  status)
    show_status "$@"
    ;;
  clear)
    clear_queue "$@"
    ;;
  -h | --help)
    print_usage
    exit 0
    ;;
  *)
    log_message "ERROR" "Unknown subcommand: $subcommand"
    print_usage
    exit 1
    ;;
  esac
}

print_usage() {
  cat <<USAGE
Usage: $(basename "$0") <subcommand> [OPTIONS]

A utility to manage the msmtp email queue.

SUBCOMMANDS:
    process              Process all queued emails (attempt to send)
    status               Show queue status and recent activity
    clear [ACCOUNT]      Clear queued emails (all accounts or specific account)

OPTIONS:
    -h, --help          Show this help message

EXAMPLES:
    $(basename "$0") process
    $(basename "$0") status
    $(basename "$0") clear
    $(basename "$0") clear gmail

NOTES:
    - Queue directory: $QUEUE_DIR
    - Log file: $LOG_FILE
    - Queued files are named: timestamp-pid-random-ACCOUNT
USAGE
}

log_message() {
  local level="$1"
  shift
  local message
  message="$(date '+%Y-%m-%d %H:%M:%S') [$level] $*"

  if [[ -d "$QUEUE_DIR" ]]; then
    echo "$message" >>"$LOG_FILE"
  fi
  echo "$message" >&2
}

process_queue() {
  if [[ $# -gt 0 ]]; then
    log_message "ERROR" "process subcommand takes no arguments"
    print_usage
    exit 1
  fi

  if ! command -v "$MSMTP_PATH" >/dev/null 2>&1; then
    log_message "ERROR" "msmtp not found at $MSMTP_PATH"
    exit 1
  fi

  setup_queue_directory

  local total_count
  total_count="$(count_queued_files)"
  if [[ "$total_count" -eq 0 ]]; then
    log_message "INFO" "No emails in queue"
    return 0
  fi

  log_message "DEBUG" "Files from get_queued_files:"
  get_queued_files | while IFS= read -r debug_file; do
    log_message "DEBUG" "  - $debug_file"
  done

  log_message "INFO" "Processing $total_count queued emails"
  local sent_count=0
  local failed_count=0
  # NOTE: Temporarily disable exit on error for msmtp call
  # so that it can continue processing other files even if
  # one fails.
  set +e
  while IFS= read -r file; do
    if [[ -n "$file" ]]; then
      local account
      account="$(extract_account_from_filename "$file")"

      log_message "INFO" "Attempting to send $(basename "$file") via $account"

      local msmtp_output
      if msmtp_output=$("$MSMTP_PATH" --account="$account" -t <"$file" 2>&1); then
        rm "$file"
        log_message "INFO" "SUCCESS: Sent $(basename "$file") via $account"
        ((sent_count++))
      else
        log_message "ERROR" "FAILED: Could not send $(basename "$file") via $account - $msmtp_output"
        ((failed_count++))
      fi
    fi
  done < <(get_queued_files)
  set -e

  log_message "INFO" "Processing complete: $sent_count sent, $failed_count failed"
}

setup_queue_directory() {
  if ! mkdir -p "$QUEUE_DIR"; then
    log_message "ERROR" "Failed to create queue directory: $QUEUE_DIR"
    exit 1
  fi
}

extract_account_from_filename() {
  local filename="$1"
  local basename_file
  basename_file="$(basename "$filename")"

  # NOTE: Expected format of timestamp-pid-random-ACCOUNT
  if [[ "$basename_file" =~ ^[0-9]+-[0-9]+-[a-fA-F0-9]+-(.+)$ ]]; then
    echo "${BASH_REMATCH[1]}"
  else
    log_message "WARN" "Could not extract account from filename: $basename_file"
    echo "unknown"
  fi
}

get_queued_files() {
  local account_filter="${1:-}"

  if [[ ! -d "$QUEUE_DIR" ]]; then
    return 0
  fi

  for file in "$QUEUE_DIR"/*; do
    if [[ -f "$file" ]]; then
      if [[ -z "$account_filter" ]]; then
        echo "$file"
      else
        local file_account
        file_account="$(extract_account_from_filename "$file")"
        if [[ "$file_account" == "$account_filter" ]]; then
          echo "$file"
        fi
      fi
    fi
  done
}

count_queued_files() {
  local account_filter="${1:-}"
  local count=0

  while IFS= read -r -d '' file; do
    ((count++))
  done < <(get_queued_files "$account_filter" | tr '\n' '\0')

  echo "$count"
}

show_status() {
  if [[ $# -gt 0 ]]; then
    log_message "ERROR" "status subcommand takes no arguments"
    print_usage
    exit 1
  fi

  setup_queue_directory

  echo "=== Queue Status ==="

  local total_count
  total_count="$(count_queued_files)"
  echo "Total queued: $total_count"

  if [[ "$total_count" -gt 0 ]]; then
    echo ""
    echo "By account:"
    while IFS= read -r account; do
      if [[ -n "$account" ]]; then
        local account_count
        account_count="$(count_queued_files "$account")"
        echo "  $account: $account_count"
      fi
    done < <(get_all_accounts)
  fi

  if [[ -f "$LOG_FILE" ]]; then
    echo ""
    echo "=== Recent Activity (last 10 lines) ==="
    tail -10 "$LOG_FILE" 2>/dev/null || echo "No log entries yet"
  fi
}

get_all_accounts() {
  local accounts=()

  while IFS= read -r file; do
    if [[ -n "$file" ]]; then
      local account
      account="$(extract_account_from_filename "$file")"
      if [[ "$account" != "unknown" ]]; then
        accounts+=("$account")
      fi
    fi
  done < <(get_queued_files)

  # Remove duplicates and sort
  printf '%s\n' "${accounts[@]}" | sort -u
}

clear_queue() {
  local account_filter="${1:-}"

  if [[ $# -gt 1 ]]; then
    log_message "ERROR" "clear subcommand takes at most one argument (account name)"
    print_usage
    exit 1
  fi

  setup_queue_directory

  if [[ -n "$account_filter" ]]; then
    local account_count
    account_count="$(count_queued_files "$account_filter")"

    if [[ "$account_count" -eq 0 ]]; then
      echo "No queued emails for account: $account_filter"
      return 0
    fi

    while IFS= read -r file; do
      if [[ -n "$file" ]]; then
        rm "$file"
      fi
    done < <(get_queued_files "$account_filter")

    log_message "INFO" "Cleared $account_count queued emails for account: $account_filter"
    echo "Cleared $account_count queued emails for account: $account_filter"
  else
    local total_count
    total_count="$(count_queued_files)"

    if [[ "$total_count" -eq 0 ]]; then
      echo "No queued emails to clear"
      return 0
    fi

    while IFS= read -r file; do
      if [[ -n "$file" ]]; then
        rm "$file"
      fi
    done < <(get_queued_files)

    log_message "INFO" "Cleared $total_count queued emails (all accounts)"
    echo "Cleared $total_count queued emails (all accounts)"
  fi
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
